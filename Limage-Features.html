

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L'Image - Home</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="particle-canvas"></canvas>

<header>
    <h1>L'Image</h1>
  <nav>
    <a href="Limage-Home.html" >Home</a>
    <a href="Limage-Features.html"class="active">Features</a>
    <a href="Limage-Publications.html">Publications</a>
  </nav>
  </header>
<section>
    <h1>Features</h1>
<h2>
File handling/image correction
</h2>

<img src="Limage 2.png" class="wrap-image" alt="Stitch">

<ul>
  <li><h3>Load .im files created by Cameca ims-xf, ims-1xxx and NanoSIMS ion probes. Load entire data file or selected species/ cycles. Optional re-binning of multiple image cycles into fewer number of cycles to increase processing speed.</h3></li>

  <li><h3>Automatic alignment of image cycles to correct for image drift.</h3></li>

  <li><h3>Correct images for EM deadtime and QSA effects on a pixel-by-pixel basis.</h3></li>

  <li><h3>Stitching of image files.</h3></li>
</ul>
<div style="margin-bottom: 200px;"></div>

<h2 style="text-align: right;">
Display/output
</h2>

<img src="Limage 2.png" class="wrap-image2" alt="Stitch">

<ul>
  <li><h3>Interactive display of images: view images for individual cycles or integrated over many cycles, mouse-driven zooming, image smoothing, linear or logarithmic color scales, pixel intensities displayed as counts or counts/second, animations of individual cycle images, manually set minimum/maximum pixel intensities to display, optionally rotate/flip images.</h3></li>

  <li><h3>Interactive image profiling: Mouse-driven interface to define line profiles. Semi-automatic spatial resolution estimation from line profiles. High-quality plot outputs and data export to spreadsheet.</h3></li>

  <li><h3>Image depth profiling (intensities for selected pixel over multiple cycles).</h3></li>

  <li><h3>Flexible control over color tables.</h3></li>
  <li><h3>Display/export pseudo-3d representations of data (contour plots, surface plots).</h3></li>
  <li><h3>Combine images/plots from various tasks and multiple image files into single-page displays.</h3></li>
  <li><h3>Generation of RGB color composites of elemental/isotopic/ratio images</h3></li>
  <li><h3>Flexible Output: Export images with or without color bars, scale bars to popular formats (JPEG, TIFF, MetaFile, etc) or copy to Windows clipboard. Optionally overlay ROI outlines. Save processed images as .im files for future analysis in Lâ€™image.</h3></li>
  
</ul>


</section>
 <footer>
    <p>&copy; 2025 L'Image </p>
  </footer>
  <script>
    const canvas = document.getElementById('particle-canvas');
    const ctx = canvas.getContext('2d');
    let particles = [];
    const numberOfParticles = 150;

    class Particle {
      constructor() {
        this.reset();
        this.y = Math.random() * canvas.height; // Start at a random y position initially
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height + Math.random() * 50; // Start just below the screen
        this.radius = Math.random() * 3 + 1;
        this.speedY = Math.random() * 1 + 0.5; // Upward speed
        this.opacity = this.radius / 4; // Smaller particles are more transparent
        this.wobble = Math.random() * 0.02 + 0.01; // Wobble speed
        this.wobbleAngle = Math.random() * Math.PI * 2;
      }

      update() {
        this.y -= this.speedY;
        this.wobbleAngle += this.wobble;
        this.x += Math.sin(this.wobbleAngle) * 0.5; // Apply horizontal wobble

        if (this.y < -this.radius) {
          this.reset();
        }
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(173, 216, 230, ${this.opacity})`; // Light blue
        ctx.shadowColor = 'rgba(0, 191, 255, 0.7)'; // Cyan glow
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.closePath();
      }
    }

    function init() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      particles = [];
      for (let i = 0; i < numberOfParticles; i++) {
        particles.push(new Particle());
      }
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.shadowBlur = 0;

      for (const particle of particles) {
        particle.update();
        particle.draw();
      }

      requestAnimationFrame(animate);
    }
    window.addEventListener('resize', init);
    init();
    animate();
  </script>
</body>
</html>
